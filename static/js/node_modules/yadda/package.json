{
  "name": "yadda",
  "version": "0.4.7",
  "description": "A true BDD framework for JavaScript",
  "main": "./lib/index.js",
  "devDependencies": {
    "mocha": "*",
    "browserify": "*",
    "casper": "*",
    "nodeunit": "*"
  },
  "directories": {
    "example": "examples",
    "test": "test"
  },
  "scripts": {
    "test": "make test",
    "examples": "./bin/examples.sh",
    "browserify": "node ./bin/browserify.js"
  },
  "repository": {
    "type": "git",
    "url": "git://github.com/acuminous/yadda.git"
  },
  "keywords": [
    "BDD",
    "Specification",
    "Natural",
    "Test",
    "Behaviour",
    "Driven",
    "Jasmine",
    "Mocha",
    "QUnit",
    "Nodeunit"
  ],
  "author": {
    "name": "Stephen Cresswell"
  },
  "license": "Apache2",
  "readmeFilename": "README.md",
  "gitHead": "4754e8449c4f6d28e6357059287079a44a0dad29",
  "readme": "# Yadda\nYadda brings _true_ BDD to JavaScript test frameworks such as [Jasmine](http://pivotal.github.io/jasmine/), [Mocha](http://visionmedia.github.io/mocha/), [QUnit](http://qunitjs.com), [Nodeunit](https://github.com/caolan/nodeunit) and [CasperJS](http://casperjs.org). By _true_ BDD we mean that the ordinary language (e.g. English) steps are mapped to code, as opposed to simply decorating it. This is important because just like comments, the decorative steps such as those used by\n[Jasmine](http://pivotal.github.com/jasmine), [Mocha](http://visionmedia.github.io/mocha) and [Vows](http://vowsjs.org), can fall out of date and are a form of duplication.\n\nYadda's BDD implementation is like [Cucumber's](http://cukes.info/) in that it maps the ordinary language steps to code. Not only are the steps less likely to go stale, but they also provide a valuable abstraction layer and encourage re-use. You could of course just use [CucumberJS](https://github.com/cucumber/cucumber-js), but we find Yadda less invasive and prefer it's flexible syntax to Gherkin's. Yadda's conflict resolution is smarter too.\n\n## Installation\nYadda 0.4.7 is the current verison. It includes an update to the casperjs example that works with the latest version from master.\n\n### Node based environments (e.g. Mocha)\n```\nnpm install yadda\n```\n### Browser based environments (e.g. QUnit)\n```html\n<script src=\"./lib/yadda-0.4.7.js\"></script>\n```\n## Writing Yadda Tests\n### Step 1 - Write your scenarios\nbottles-spec.txt\n```\nScenario: should fall from the wall\n\n   Given 100 green bottles are standing on the wall\n   When 1 green bottle accidentally falls\n   Then there are 99 green bottles standing on the wall\n```\n(You aren't restricted to just Given/When/Then. You can use any words you like)\n\n### Step 2 - Implement the step library\nbottles-library.js\n```js\nvar assert = require('assert');\nvar Library = require('yadda').localisation.English;\n\nmodule.exports = (function() {\n  var library = new Library()\n    .given(\"$NUM green bottles are standing on the wall\", function(number, next) {\n       wall = new Wall(number);\n       next();\n    })\n    .when(\"$NUM green bottle accidentally falls\", function(number, next) {\n       wall.fall(number);\n       next();\n    })\n    .then(\"there are $NUM green bottles standing on the wall\", function(number, next) {\n       assert.equal(number, wall.bottles);\n       next();\n    });\n})();\n```\n(If your test runner & code are synchronous you can omit the calls to 'next')\n\n\n### Step 3 - Integrate Yadda with your testing framework (e.g. Mocha)\nbottles-test.js\n```js\nvar Yadda = requre('yadda').Yadda;\nvar MochaPlugin = ('yadda').plugins.MochaPlugin;\nvar library = require('./bottles-library');\nvar yadda = new Yadda(library);\n\nnew MochaPlugin().upgrade(Yadda);\n\nyadda.mocha('Bottles', './bottles-spec.txt');\n```\n\n### Step 4 - Run your tests\n```\n  mocha --reporter spec bottles-test.js\n\n  Bottles\n    âœ“ should fall from the wall\n```\n\n## Features\n### Supported Libraries\nYadda works with Mocha, Jasmine, QUnit, Nodeunit, ZombieJS and CasperJS. See the examples for details.\n\n### Flexible BDD Syntax\nIt's common for BDD libraries to limit syntax to precondition (given) steps, action (when) steps and assertion (then) steps. Yadda doesn't. This allows for more freedom of expression. e.g.\n```js\nvar library = new Yadda.Library()\n    .define(\"$NUM green bottle(?:s){0,1} standing on the wall\", function(number) {\n        // some code\n    })\n    .define(\"if $NUM green bottle(?:s){0,1} should accendentally fall\", function(number) {\n        // some code\n    })\n    .define(\"there are $NUM green bottle(?:s){0,1} standing on the wall\", function(number) {\n        // some code\n    });\nnew Yadda.yadda(library).yadda([\n    \"100 green bottles standing on the wall\",\n    \"if 1 green bottle should accidentally fall\",\n    \"there are 99 green bottles standing on the wall\"\n]);\n```\nHowever we think that Given/When/Then (along with And/But/With) is a good starting point, so we recommend using Yadda.localisation.English instead of the vanilla Yadda.Library. This adds 'given', 'when', 'then', 'and', 'but' and 'with' helper methods, enabling you to define your steps as follows...\n```js\nvar library = new Yadda.Library()\n    .given(\"$NUM green bottle(?:s){0,1} standing on the wall\", function(number) {\n        // some code\n    })\n    .when(\"$NUM green bottle(?:s){0,1} should accendentally fall\", function(number) {\n        // some code\n    })\n    .then(\"there are $NUM green bottle(?:s){0,1} standing on the wall\", function(number) {\n        // some code\n    });\nnew Yadda.yadda(library).yadda([\n    \"Given 100 green bottles standing on the wall\",\n    \"when 1 green bottle should accidentally fall\",\n    \"then there are 99 green bottles standing on the wall\"\n]);\n```\nWe'd be delighted to accept pull requests for more languages and dialects.\n\n### Step Anatomy\nA step is made up of a regular expression, a function and some context.\n```js\nvar ctx = { assert: assert };\nlibrary.given('^(\\\\d+) green bottle(?:s){0,1} standing on the wall$', function(n) {\n   wall = new Wall(n);\n   this.assert.equals(wall.bottles, n);\n}, ctx);\n```\n\n#### Regular Expressions\nThe regular expression is used to identify which steps are compatible with the input text, and to provide arguments to the function. You can specify step signatures using true RegExp object, which is handy if they contain lots of backslash characters. e.g.\n```js\nvar library = new Yadda.Library.English()\n    .given(/^(\\d+) green bottle(?:s){0,1} standing on the wall$/, function(n) {\n        // some code\n    });\n```\nRegular expressions can get pretty ugly, so it's often preferable to relax the regex and use a $term variable which will be replaced with a wildcard i.e. '(.+)'.\n```js\nvar library = new Yadda.Library.English()\n    .given(/$NUM green bottles standing on the wall/, function(n) {\n        // some code\n    });\n```\nUsing $term variables can relax the regular expression too much and cause clashes between steps. Yadda provides greater control over the expansion through use of a dictionary, e.g.\n```js\nvar dictionary = new Yadda.Dictionary()\n    .define('gender', '(male|female)')\n    .define('speciaility', '(cardio|elderly|gastro)');\n\nvar library = new Yadda.Library.English(dictionary)\n    .given('a $gender, $speciality patient called $name', function(gender, speciality, name) { /* some code */ });\n```\nwill expand to\n```js\n\"(?:[Gg]iven|[Aa]nd|[Ww]ith]|[Bb]ut) a (male|female), (cardio|elderly|gastro) patient called (.+)\"\n```\nand therefore match \"Given a female, elderly patient called Carol\". The expansions can also contain $terms so\n```js\nvar dictionary = new Yadda.Dictionary()\n    .define('address_line_1', '$number $street')\n    .define('number', /(\\d+)/)\n    .define('street', /(\\w+)/);\n\nvar library = new Yadda.Library.English(dictionary)\n    .given('a street address of $address_line_1', function(number, street) { /* some code */ });\n```\nwill expand to\n```js\n\"(?:[Gg]iven|[Aa]nd|[Ww]ith]|[Bb]ut) a street address of (\\d+) (\\w+)\"\n```\n\n#### Functions\nThe function is the code you want to execute for a specific line of text. If you don't specify a function then a no-op\nfunction will be used, which is Yadda's way of implementing a 'Pending' step.\n\n#### Contexts (Shared State)\nThe context will be bound with the function before it is executed and provides a non global way to share state between\nsteps, or pass in define time variables such as an assertion library or 'done' function. The context is also optional.\n\nIt can be a chore to add a context to every step, so a common context can be specified at the interpreter and scenario levels too...\n```js\n // Shared between all scenarios\nnew Yadda.yadda(library, ctx);\n\n// Shared between all steps in this scenario\nnew Yadda.yadda(library).yadda('Some scenario', ctx, done);\n```\nIf you specify multiple contexts they will be merged before executing the step.\n\n#### Step Conflicts\nOne issue you find with BDD libraries, is that two steps might match the same input text. Usually this results in an error, and you end up having to add some extra text to one of the steps in order to differentiate it. Yadda attempts to minimise this in three ways.\n\n1. By using the Levenshtein Distance to determine which step is the best match when clashes occur.\n\n2. By allowing you to define steps in multiple libraries. Grouping steps into libraries not only helps keep a tidy code base, but also prevents clashes if you scenario doesn't require the library with the alternative step.\n\n3. If you still have problems with clashing, you can use the term dictionary to make your regular expression more specific without affecting the readability of your step.\n",
  "bugs": {
    "url": "https://github.com/acuminous/yadda/issues"
  },
  "_id": "yadda@0.4.7",
  "dist": {
    "shasum": "37a2d36f3b1264182fdd08ef022043dfe42f481f"
  },
  "_from": "yadda@",
  "_resolved": "https://registry.npmjs.org/yadda/-/yadda-0.4.7.tgz"
}
